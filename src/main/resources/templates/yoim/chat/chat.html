<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5">
<head>
  <meta charset="UTF-8" />
  <title>YOIM DM</title>
  <style>
    body{font-family:system-ui,apple sd gothic neo,Malgun Gothic,Arial,sans-serif;margin:0;display:flex;height:100vh}
    aside{width:260px;border-right:1px solid #eee;padding:12px;overflow:auto}
    main{flex:1;display:flex;flex-direction:column}
    header{display:flex;justify-content:space-between;align-items:center;padding:10px 14px;border-bottom:1px solid #eee}
    .msgs{flex:1;overflow:auto;padding:12px;display:flex;flex-direction:column;gap:10px}
    .input{display:flex;gap:8px;padding:12px;border-top:1px solid #eee}
    .input input{flex:1;padding:10px;border:1px solid #ddd;border-radius:8px}
    .input button{padding:10px 14px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer}
    .msg{display:flex;flex-direction:column;gap:4px}
    .bubble{display:inline-block;border:1px solid #eee;border-radius:12px;padding:8px 10px;max-width:70%}
    .mine .bubble{border-color:#cfe3ff;background:#f6faff;align-self:flex-end}
    .meta{font-size:12px;color:#888}
    .meta .read{opacity:.9}
    .meta .reg{opacity:.9}
    .dm-only aside{display:none}
  </style>
</head>
<body class="dm-only">
<aside id="sidebar">
  <h3 style="margin:8px 0;">Rooms</h3>
  <div id="rooms"></div>
</aside>

<main>
  <header>
    <div>
      <b id="roomTitle">Direct Message</b>
      <span id="peerInfo" style="color:#888;margin-left:6px;"></span>
    </div>
    <div id="meInfo" style="color:#666;"></div>
  </header>

  <div class="msgs" id="msgs"></div>

  <div class="input">
    <input id="msgInput" type="text" placeholder="메시지 입력…" />
    <button id="sendBtn">Send</button>
  </div>
</main>

<script th:inline="javascript">
  window.ME = /*[[${me}]]*/ 0;
  window.TO = /*[[${to}]]*/ 0;
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

<script>
  // ===== 상태 =====
  let currentRoomId = null;
  let stompClient = null;
  let roomSub = null;
  let lastSeq = 0;

  const msgIndex = new Map();   // key -> {$row, data}
  const membersById = {};       // userId -> { last_read_seq, last_read_dt }

  // ===== API =====
  const api = {
    myRooms: (userId) => $.getJSON(`/api/chat/rooms?userId=${userId}`),
    createDm: (me, peer) => $.ajax({
      url: '/api/chat/rooms', method: 'POST', contentType: 'application/json',
      data: JSON.stringify({ type:1, roomName:null, members:[me, peer], me })
    }),
    findDm: (me, peer) => $.getJSON(`/api/chat/dm?me=${me}&peer=${peer}`)
            .catch(() => $.getJSON(`/api/chat/rooms/dm?me=${me}&peer=${peer}`)),
    messages: (roomId, beforeSeq=null, limit=50) =>
            $.getJSON(`/api/chat/rooms/${roomId}/messages`, { beforeSeq, limit }),
    members: (roomId) => $.getJSON(`/api/chat/rooms/${roomId}/members`),
    markRead: (roomId, userId, lastSeqVal) => $.ajax({
      url: `/api/chat/rooms/${roomId}/read`, method: 'POST',
      contentType: 'application/json', data: JSON.stringify({ userId, lastSeq: lastSeqVal })
    }),
  };

  // ===== 유틸 =====
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function scrollBottom(){ const el = document.getElementById('msgs'); el.scrollTop = el.scrollHeight; }
  function pad2(n){ return (n<10?'0':'')+n; }
  function normalizeTs(ts){
    if (ts == null) return null;
    const num = Number(ts); if (!isFinite(num)) return null;
    return (num < 1e12) ? num * 1000 : num; // 10자리 초, 13자리 ms
  }
  function pickFirst(obj, keys){ for (const k of keys){ if (obj[k] != null) return obj[k]; } return null; }
  function formatYmdHm(ts){
    const ms = normalizeTs(ts); if (ms == null) return '';
    const d = new Date(ms);
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
  }

  // ===== 키/인덱스 =====
  function msgKey(m){
    const rid = Number(m.roomId ?? m.room_id ?? currentRoomId ?? 0);
    const seq = Number(m.seq ?? m.msgSeq ?? m.msg_id ?? m.id ?? 0) || `${Date.now()}-${Math.random()}`;
    return `${rid}:${seq}`;
  }

  // ===== 렌더 =====
  function metaHtml(m){
    const seqText = (m.seq ?? '');
    const sender = (m.senderId ?? m.sender_id ?? 'SYS');

    const createdRaw = pickFirst(m, ['registMs','regist_ts','registDt','regist_dt','createdAt','created_at','ts','timestamp','time','sentAt','sent_at']);
    const readRaw    = pickFirst(m, ['readMs','readAt','read_at','readDt','read_dt','readTime','read_time','last_read_at']);
    const created    = createdRaw ? formatYmdHm(createdRaw) : '';

    const mine = Number(m.senderId ?? m.sender_id) === Number(window.ME);
    let readStr = '';
    if (mine) {
      if (readRaw === true) readStr = '읽음';
      else if (readRaw)     readStr = '읽음 ' + formatYmdHm(readRaw);
    }

    return `
      <span class="seq">#${seqText}</span>
      <span class="sep"> · </span>
      <span class="sender">${sender}</span>
      <span class="reg">${created ? ' · ' + created : ''}</span>
      <span class="read">${readStr ? ' · ' + readStr : ''}</span>
    `;
  }

  function updateMeta($row, m){ $row.find('.meta').html(metaHtml(m)); }

  function clearMessages(){ $('#msgs').empty(); lastSeq = 0; msgIndex.clear(); }

  function upsertMessage(m, autoScroll=true){
    // 숫자 강제
    if (m.seq != null) m.seq = Number(m.seq);
    if (m.senderId != null) m.senderId = Number(m.senderId ?? m.sender_id);

    const key = msgKey(m);
    const mine = Number(m.senderId ?? m.sender_id) === Number(window.ME);

    let item = msgIndex.get(key);
    if (item){
      item.data = { ...item.data, ...m };
      item.$row.find('.bubble').html(escapeHtml(item.data.content || ''));
      updateMeta(item.$row, item.data);
    } else {
      const $row = $(`
        <div class="msg ${mine ? 'mine' : ''}" data-key="${key}">
          <div class="meta"></div>
          <div class="bubble">${escapeHtml(m.content || '')}</div>
        </div>
      `);
      $('#msgs').append($row);
      item = { $row, data: { ...m } };
      msgIndex.set(key, item);
      updateMeta($row, item.data);
    }

    if (m.seq) lastSeq = Math.max(lastSeq, Number(m.seq));
    if (autoScroll) scrollBottom();
    return key;
  }

  function applyReadMarksWithMembers(msgs){
    const me  = Number(window.ME);
    const to  = Number(window.TO);
    const peerState = membersById[to] || { last_read_seq: 0, lastReadSeq: 0, last_read_dt: null };

    const peerLastSeq = Number(peerState.last_read_seq ?? peerState.lastReadSeq ?? 0);

    (msgs||[]).forEach(m => {
      const mine = Number(m.senderId ?? m.sender_id) === me;
      const seqN = Number(m.seq ?? 0);
      if (mine && seqN && seqN <= peerLastSeq){
        const dt = (peerState.last_read_dt != null ? peerState.last_read_dt : null);
        m.readMs = (dt != null) ? dt : true; // 시간 없으면 '읽음'만
      }
      upsertMessage(m, false);
    });
    scrollBottom();
  }

  function renderMessages(msgs){
    clearMessages();
    applyReadMarksWithMembers(msgs);
  }

  // ===== WS =====
  function connectWs(onConnected){
    if (stompClient && stompClient.connected) { onConnected && onConnected(); return; }
    const sock = new SockJS('/ws');
    stompClient = Stomp.over(sock);
    stompClient.debug = () => {};
    stompClient.connect({}, () => onConnected && onConnected());
  }
  function unsubscribeRoom(){ if (roomSub) { try{ roomSub.unsubscribe(); }catch(_){} roomSub = null; } }

  function handleRoomEvent(payload){
    const dto = typeof payload === 'string' ? JSON.parse(payload) : payload;
    const ev  = dto.event || dto.type || 'MESSAGE';

    if (ev === 'READ'){
      const userId = Number(dto.userId || dto.user_id);
      const seq    = Number(dto.seq || 0);
      const readAt = dto.readAt || dto.read_at || Date.now();

      if (!membersById[userId]) membersById[userId] = { last_read_seq: 0, last_read_dt: null };
      membersById[userId].last_read_seq = Math.max(Number(membersById[userId].last_read_seq||0), seq);
      membersById[userId].last_read_dt  = readAt;

      // 내 메시지(오른쪽)만 업데이트
      const me = Number(window.ME);
      for (const [key, item] of msgIndex){
        const d = item.data;
        const dSeq = Number(d.seq || 0);
        if (Number(d.senderId ?? d.sender_id) === me && dSeq && dSeq <= membersById[userId].last_read_seq){
          d.readMs = membersById[userId].last_read_dt ?? true;
          updateMeta(item.$row, d);
        }
      }
      return;
    }

    // MESSAGE
    const key = upsertMessage(dto);

    // 상대가 보낸 메시지를 내가 읽었다 → 서버에만 업데이트 (상대 버블에는 읽음표시 금지)
    const mine = Number(dto.senderId ?? dto.sender_id) === Number(window.ME);
    if (!mine && dto.seq){
      api.markRead(currentRoomId, window.ME, Number(dto.seq)).catch(()=>{});
      const me = Number(window.ME);
      if (!membersById[me]) membersById[me] = { last_read_seq: 0, last_read_dt: null };
      membersById[me].last_read_seq = Math.max(Number(membersById[me].last_read_seq||0), Number(dto.seq));
      membersById[me].last_read_dt  = Date.now();
    }
  }

  function subscribeRoom(roomId){
    unsubscribeRoom();
    roomSub = stompClient.subscribe(`/topic/rooms/${roomId}`, (frame) => handleRoomEvent(frame.body));
  }

  function sendMessage(text){
    if (!currentRoomId || !stompClient || !stompClient.connected) return;
    const payload = { roomId: currentRoomId, senderId: window.ME, msgType: 1, content: text };
    stompClient.send(`/app/rooms/${currentRoomId}/send`, {}, JSON.stringify(payload));
  }

  // ===== DM 보장 =====
  async function ensureDm(me, peer){
    try {
      const dm = await api.findDm(me, peer);
      if (dm && (dm.roomId || dm.room_id)) return dm.roomId || dm.room_id;
    } catch (_e) { /* ignore */ }

    try {
      const res = await api.createDm(me, peer);
      return res.roomId || res.room_id || res.id || (res.data && (res.data.roomId || res.data.room_id));
    } catch (e) {
      const rooms = await api.myRooms(me);
      const match = (rooms||[]).find(r =>
                      Number(r.room_type) === 1 && (
                              (r.dmPeerId && Number(r.dmPeerId) === Number(peer)) ||
                              (Array.isArray(r.members) && r.members.includes(Number(me)) && r.members.includes(Number(peer)))
                      )
      );
      if (match) return match.room_id || match.roomId;
      throw e;
    }
  }

  // ===== 멤버 읽음상태 로드 =====
  async function loadMembers(roomId){
    try {
      const list = await api.members(roomId);
      (list||[]).forEach(m => {
        const uid = Number(m.userId || m.user_id);
        membersById[uid] = {
          last_read_seq: Number((m.last_read_seq ?? m.lastReadSeq) || 0),
          last_read_dt:  m.last_read_dt || null,
        };
      });
    } catch(_e){ /* 없으면 무시 */ }
  }

  // ===== DM 진입 =====
  async function enterDm(roomId){
    currentRoomId = Number(roomId);
    $('#meInfo').text(`me: ${window.ME}`);
    $('#peerInfo').text(`상대: ${window.TO} (room: ${roomId})`);

    await loadMembers(roomId);

    const res = await api.messages(roomId, null, 50);
    let msgs = res;
    if (res && res.messages){
      msgs = res.messages;
      if (Array.isArray(res.members)){
        res.members.forEach(m => {
          const uid = Number(m.userId || m.user_id);
          membersById[uid] = {
            last_read_seq: Number((m.last_read_seq ?? m.lastReadSeq) || 0),
            last_read_dt:  m.last_read_dt || null,
          };
        });
      }
    }

    renderMessages((msgs || []).reverse());

    if (lastSeq) {
      try { await api.markRead(roomId, window.ME, Number(lastSeq)); } catch(_e){}
      const me = Number(window.ME);
      if (!membersById[me]) membersById[me] = { last_read_seq: 0, last_read_dt: null };
      membersById[me].last_read_seq = Math.max(Number(membersById[me].last_read_seq||0), Number(lastSeq));
      membersById[me].last_read_dt  = Date.now();
    }

    connectWs(() => subscribeRoom(roomId));
  }

  // ===== 시작 =====
  $(document).ready(async function(){
    const me = Number(window.ME || 0);
    const to = Number(window.TO || 0);
    if (!me) { alert('로그인 정보가 없습니다. (ME=0)'); return; }

    if (to && to !== me) {
      try { const roomId = await ensureDm(me, to); await enterDm(roomId); }
      catch (e){ console.error(e); alert('DM 방을 준비하는 중 오류가 발생했습니다.'); }
    } else {
      document.body.classList.remove('dm-only');
      const rooms = await api.myRooms(me);
      if (rooms && rooms.length) {
        const first = rooms[0];
        await enterDm(first.room_id || first.roomId);
      }
    }

    function doSend(){
      const v = $('#msgInput').val().trim();
      if (!v) return;
      sendMessage(v);
      $('#msgInput').val('');
    }
    $('#sendBtn').on('click', doSend);
    $('#msgInput').on('keydown', (e)=>{ if (e.key === 'Enter') doSend(); });
  });
</script>
</body>
</html>
